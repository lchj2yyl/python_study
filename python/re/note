正则表达式是由特殊字符和元字符组成的字符串

正则表达式字符串 --编译-- 正则表达式对象 --匹配字符串--- 匹配结果

常用元字符
. 任意对象
\d 数字
\D 非数字
\s 空白字符
\S 非空白字符
\w [a-zA-Z_]
\W [^a-zA-Z_]
[] 匹配[]中列举的字符
\ 是转移字符 匹配文本中的\是需要'\\\\',为什么需要四个'\\'打印出来是\,字符串会进行转义，\在正则中也是转移字符，所以正则中需要'\\',所以字符串中需要'\\\\',使用python中原生字符r'\\',r开始的字符串或略或者自动补全转移字符，\代表的就是\,同时注意
foo = '\\w'
bar = '\w'
print foo # \w
print bar # \w
print foo == bar # True

猜测为 \w转移失败则重新，直接当做\来处理
后续证明\w直接转换为了\w 例如‘\1' 输出为none 不是‘\1'
存在以下关系 
'\\w' == '\w'
'\\1' != '\1'

表示数量的字符
* {0, n} n为无穷大
+ {1, n} n为无穷大
? {0, 1} 
{n,} 至少出现n次
{n, m} 至少出现n次，最多m次
{, m} 最多出现m次

贪婪和非贪婪
贪婪就是尽可能多的匹配，非贪婪就是尽可能少的匹配，这个各个语言实现不同，python中默认的是贪婪，非贪婪在后数量后面加? *? +? ?? {n, }? {n, m}? {, m}?

表示边界的字符
^ 表示一行的开始
$ 表示一行的结束

分组匹配
| |左右各一个正则表达式，匹配其中任一一个
() 表示一个分组
\num 引用一个分组 这种形式去是r'\1' 或者‘\\1', 分组为0为整个匹配结果， 分组1为第一个括号中的分组
(?P<group_name>) 定义分组名称
(?p=group_name)


search 
在字符串中搜索,正则的匹配不是从字符串的开头开始匹配，而match是从开头开始匹配
这个匹配到一个即会返回匹配结果

findall
和search类似不从开头开始匹配，会搜索整个字符串，返回搜索结果，元祖

sub
将匹配到字符串进行替换




